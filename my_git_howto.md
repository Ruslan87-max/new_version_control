# My git-howto-instruction

# Шпаргалка по git

### Настроийки 
Необходимы для того, чтобы когда вы создавали commit, указывался автор, кто его создал:
+ ```sh
    git config --global user.name "<user_name>"
  ```

+ ```sh
    git config --global user.email "<user's_email_address>"
  ```
### Создание локального репозитория
```sh
git init 
```
### Работа с папками
- Перейти по каталогу папок на уровень выше
  ```sh
  cd ../
  ```
+ Перейти в нужную папку
  ```sh
  cd /<full_path>/<folder_name>/
  ```
* Создание директории
  ```sh
  mkdir "<folder_name>" 
  ```
+ Просмотр содержимого данной папки
  ```sh
  git ls
  ```
- Отображение полного пути к даннй папке
  ```sh
  git pwd
  ```
### Работа с коммитами
1. Фиксация изменений
    * Маркировка папки или файла в данном репозитории для его отслеживания
      ```sh
      git add <folder_name> | <file_name>
      ```
    * Маркировка всех файлов или папок в данном репозитории
      ```sh
      git add --all
      ```
    + Фиксацмя всех изменений (создание коммита) отслеживаемого файла или папки в репозитории
      ```sh
      git commit -m "<Message>"
      ```
    + Начать интерактивный сеанс индексирования, во время которого вы сможете выбрать части файла, которые будут добавлены в следующий коммит. Команда представит фрагмент изменений и предложит вам ввести команду. Введите `y`, чтобы проиндексировать фрагмент; `n`, чтобы игнорировать фрагмент; `s`, чтобы разбить его на более мелкие фрагменты; `e`, чтобы вручную отредактировать фрагмент; `q`, чтобы завершить работу с командой.
      ```sh
      git add -p  
      ```  
    + Команда для опытных пользователей с параметрами `-a` и `-m`. Эта комбинация параметров создает коммит всех проиндексированных файлов (изменений) и добавляет к коммиту подставленный комментарий.
      ```sh
      git commit -am "commit message"
      ```
    + Этот параметр добавляет команде commit новый уровень функциональности. При передаче этого параметра будет изменен последний коммит. Вместо создания нового коммита проиндексированные изменения будут добавлены в предыдущий коммит. Кроме того, эта команда откроет настроенный текстовый редактор системы с предложением изменить указанный ранее комментарий к коммиту.
      ```sh
      git commit --amend
      ```

2. Вывод информации о коммитах
    + Вывести список всех коммитов в данном репозитории
      ```sh
      git log
      ```
    + Вывести краткий список всех коммитов в данном репозитории
      ```sh
      git --oneline log
      ```
    + Здесь содержится несколько полезных параметров: флаг `--graph` создает основанную на тексте диаграмму коммитов в левой части области сообщений коммитов; флаг `--decorate` добавляет отображаемые имена веток или теги коммитов; флаг `--oneline` записывает информацию о коммите в одну строку, что позволяет без труда просматривать множество коммитов сразу.
      ```sh
      git log --graph --decorate --oneline
      ```
3. Работа с коммитами в ветках
    + Переход в нужный коммит репозитория
      ```sh
      git checkout <has_of_a_commit>
      ```
    + Смотрим разницу между последним коммитом и текущим состоянием репозитория
      ```sh
      git diff 
      ```
    + Разница между последним коммитом и коммитом с указанным хешем 
      ```sh
      git diff <commit_hash> <commit_hash>
      ```
### Работа с ветками
+ Отображение всех веток
  ```sh
  git branch 
  ```
+ Создание новой ветки в репозитории
  ```sh
  git branch <new_branch_name>
  ```
+ Переключение между ветками
  ```sh
  git checkout <branch_name>
  ```
+ Внесение изменений из ветки `<branch_name>` в текущую ветку (master)
  ```sh
  git merge <branch_name>
  ```
### Отмена изменений
+ Команда gдля отмены изменений.
  ```sh
  git reset <hash_of_commit>
  ```
  Команда git reset перемещает и указатель HEAD, и указатель ветки на заданный коммит.
+ При использовании аргумента --hard указатели в истории коммитов обновляются на указанный коммит. Затем происходит сброс раздела проиндексированных файлов и рабочего каталога до указанного коммита. Все предыдущие ожидающие изменения в разделе проиндексированных файлов и рабочем каталоге сбрасываются в соответствии с состоянием дерева коммитов. Это значит, что любая работа, находившаяся в состоянии ожидания в разделе проиндексированных файлов и рабочем каталоге, будет потеряна.
  ```sh
  git reset --hard <hash_of_commit>
  ```
+ Это режим работы по умолчанию. Указатели ссылок обновляются. Раздел проиндексированных файлов сбрасывается до состояния указанного коммита. Любые изменения, которые были отменены в разделе проиндексированных файлов, перемещаются в рабочий каталог. 
  ```sh
  git reset --mixed <hash_of_commit>
  ```
+ При передаче аргумента --soft выполняется обновление указателей, и на этом операция сброса останавливается. Раздел проиндексированных файлов и рабочий каталог остаются неизменными. 
  ```sh
  git reset --soft <hash_of_commit>
  ```
### Переписывание истории
+ Перемещения последовательности коммитов к новому базовому коммиту или их объединение.
  ```sh
  git rebase <base>
  ```
  Текущая ветка автоматически перебазируется на основание ＜base＞.
+ Удаление определённых комиттов в конце ветки. Например, нужно удалить три посдедних комитта:
  ```sh
  git rebase --interactive HEAD~3
  ```
  или
  ```sh
  git rebase -i HEAD~3
  ```
  Опция `--interactive` (`-i`) создаёт лист с коммитами в ветке, которые подлежат операции `rebase`. Откроется окно текстового редактора интерактивного ребейза. Например:
  ```sh
  pick bcdc461 fix something
  pick 4133a5f the awesome commit
  pick e0ca1b1 the last commit
  # Rebase 44211de..e0cga8b onto 55012de  
  #
  # Commands:
  # p, pick = use commit
  # r, reword = use commit, but edit the commit message
  # e, edit = use commit, but stop for amending
  # s, squash = use commit, but meld into previous commit
  # f, fixup = like "squash", but discard this commit's log m
  # x, exec = run command (the rest of the line) using shell
  ```
  Тут нужно заменить pick на squash для двух последних коммитов. Список читается снизу вверх, таким образом последний коммит, это самый нижний коммит в списке.
  ```sh
  pick bcdc461 fix something
  squash 4133a5f the awesome commit
  squash e0ca1b1 the last commit
  # Rebase 44211de..e0cga8b onto 55012de
  #
  # Commands:
  # p, pick = use commit
  # r, reword = use commit, but edit the commit message
  # e, edit = use commit, but stop for amending
  # s, squash = use commit, but meld into previous commit
  # f, fixup = like "squash", but discard this commit's log m
  # x, exec = run command (the rest of the line) using shell
  ```
  Сохраняем файл и в следующем открывшемся окне вводим комментарий для нового коммита.  

  ### Работа с тэгами
  #### Теги — это ссылки, указывающие на определенные точки в истории Git. Команда git tag обычно используется для захвата некой точки в истории, которая используется для релиза нумерованной версии (например, v1.0.1).  Теги похожи на неизменяемые ветки, но они, в отличие от веток, не имеют истории коммитов после создания. 
  + Для создания нового тега выполните следующую команду:
    ```sh
    git tag <tagname>
    ```
  + При выполнении этой команды будет создан аннотируемый тег с идентификатором, для примера, v1.4. Затем команда откроет настроенный текстовый редактор по умолчанию, чтобы запросить ввод дальнейших метаданных.
    ```sh
    git tag -a v1.4
    ```  
  + Эта команда аналогична предыдущей, однако в этой версии передаются параметр -m и комментарий. Этот удобный способ похож на команду git commit -m, так как с его помощью новый тег создается без открытия локального текстового редактора. Вместо этого применяется комментарий, переданный после параметра -m.
    ```sh
    git tag -a v1.4 -m "my version 1.4"
    ```   
    
### Работа с удаленными репозиториями
1. #### Создание удаленного пользовательского репозитория
    На ресурсе [https://github.com/](https://github.com/ "") cоздаём свой аккааунт. Создаём новый репозиторй в аккаунте. Далее `github` предлагает пользователю набор инструкций для клонирования своего удаленного репозитория на локальный репозиторий.\
  Важно!!! Локальный репозиторий пред клонированием необходимо проинициализировать с помощью `git init`!!! 

    + Клонирование удаленного репозитория на локальный (проинициализированный.)
      ```sh
      git remote add origin <HTTP/SSH-path_to remote_repository>
      ``` 
    + Переименовывание главной ветки в `main`.
      ```sh
      git branch -M main
      ```
    + Отправить локальный репозиторий на сервер (удаленный репоз.)
      ```sh
      git push -u origin main
      ```
2. #### Клонирование удаленного пользовательского репозитория
    Для клонирования удаленного репозитория выполняем следующие шаги:
      + Создаем папку локально на компьютере (инициализировать её не нружно!!!)
      + В программе `Git Bush` выполняем команду:
        ```sh
        git clone <HTTP/SSH-path_to remote_repository>
        ```
3. #### Отправка изменений на сервер
    После зафиксированных изменений на локальном репозитории из ветки `main` для отправки изменений на сервер нужнр выполнить команду:
    ```sh
      git push origin main
    ```
   Для отправки изменений из другой ветки нужно выполлнить команду:
    ```sh
      git push --set-upstream origin <local-branch>
    ```
    или
    ```sh
      git push -u origin <local-branch>
    ```
4. ### Разрешение конфликтов слияния с
    Если версии файлов отличаются в на сервере и локальном репозитории, то при выполнении каманды `push` произойдёт конфликт сияния версий, который разрешается командой:
    ```sh
      git pull --rebase
    ```
    При этом происходит слияние версий с возможностью разрешить конфликт. Далее нужно следоваьт инструкциям.
    После разрешения конфликта выполняются стандартные операции `add`, `commit`, `push`. 
4. ### Просмотр информации на удалённом репозитории
    + Команда просмотра полной информации на `remote` репозитории:
      ```sh
      git remote show origin
      ```
    + Команда просмотра полной информации на `remote` репозитории:
      ```sh
      git remote -v
      ```




